{
	// Place your snippets for cpp here. Each snippet is defined under a snippet name and has a prefix, body and 
	// description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. Placeholders with the 
	// same ids are connected.
	// Example:
	// "Print to console": {
	// 	"prefix": "log",
	// 	"body": [
	// 		"console.log('$1');",
	// 		"$2"
	// 	],
	// 	"description": "Log output to console"
	// }

	"Compact Include":{
		"prefix": "compact_include",
		"body": [
			"#include<bits/stdc++.h>",
			"#include<ext/pb_ds/assoc_container.hpp>",
			"#include<ext/pb_ds/tree_policy.hpp>",
			"template<class T, class _Cmp = std::less<T>>",
			"using ordered_set = __gnu_pbds::tree<T, __gnu_pbds::null_type, _Cmp, __gnu_pbds::rb_tree_tag, __gnu_pbds::tree_order_statistics_node_update>;",
			"#ifdef LOCAL",
			"#include \"debug.hpp\"",
			"#else ",
			"#define debug(...) ",
			"#endif",
			"using namespace std;",
			"using ll = long long;",
			"using ld = long double;",
			"",
			"",
			"int main(){",
			"    ios_base::sync_with_stdio(false);",
			"    cin.tie(0);",
			"    cout.tie(0);",
			"",
			"    ",
			"",
			"    return 0;",
			"}",
		]
	},

	"Competitive Programming":{
		"prefix": "#include",
		"body":[
			"#include<bits/stdc++.h>",
			"#include<ext/pb_ds/assoc_container.hpp>",
			"#include<ext/pb_ds/tree_policy.hpp>",
			"template<class T, class _Cmp = std::less<T>>",
			"using ordered_set = __gnu_pbds::tree<T, __gnu_pbds::null_type, _Cmp, __gnu_pbds::rb_tree_tag, __gnu_pbds::tree_order_statistics_node_update>;",
			"using namespace std;",
			"using ll = long long;",
			"using ld = long double;",
			"#ifdef LOCAL",
			"#include \"debug.hpp\"",
			"#else",
			"#define debug(...)",
			"#endif",
			"",
			"void Solve(){",
			"",
			"}",
			"",
			"int main(){",
			"    ios_base::sync_with_stdio(false);",
			"    cin.tie(0);",
			"    cout.tie(0);",
			"",
			"    int T = 1;",
			"    cin >> T;",
			"    for (int i = 1; i <= T; i++){",
			"        // cout << \"Case #\" << i << \": \";",
			"        // cerr << \"Case #\" << i << \": \\n\";",
			"        Solve();",
			"    }",
			"",
			"    return 0;",
			"}",
		]
	},

	"Double linked-list":{
		"prefix": "double_linked_list",
		"body": [
			"template<class T>",
			"class DoubleLinkedList{",
			"    public:",
			"    struct dllNode{",
			"        T val;",
			"        dllNode *next, *prev;",
			"        dllNode(T val, dllNode *next, dllNode *prev){",
			"            this->val = val;",
			"            this->next = next;",
			"            this->prev = prev;",
			"        }",
			"    };",
			"",
			"    int length;",
			"    dllNode *head, *tail;",
			"    doubleLinkedList(){",
			"        head = NULL;",
			"        tail = NULL;",
			"        length = 0;",
			"    }",
			"",
			"    void push_front(T val){",
			"        dllNode *node = new dllNode(val, head, NULL);",
			"        if (length == 0) tail = node;",
			"        else head->prev = node;",
			"        head = node;",
			"        length++;",
			"    }",
			"",
			"    void push_back(T val){",
			"        dllNode *node = new dllNode(val, NULL, tail);",
			"        if (length == 0) head = node;",
			"        else tail->next = node;",
			"        tail = node;",
			"        length++;",
			"    }",
			"",
			"    void pop_front(){",
			"        assert(length > 0);",
			"        if (length == 1) tail = NULL;",
			"        head = head->next;",
			"        length--;",
			"    }",
			"",
			"    void pop_back(){",
			"        assert(length > 0);",
			"        if (length == 1) head = NULL;",
			"        tail = tail->prev;",
			"        length--;",
			"    }",
			"",
			"    T front(){",
			"        assert(length > 0);",
			"        return head->val;",
			"    }",
			"",
			"    T back(){",
			"        assert(length > 0);",
			"        return tail->val;",
			"    }",
			"};",
		]
	},

	"Matrix" :{
		"prefix": "matrix_operations",
		"body": [
			"template<class T>",
			"class Matrix{",
			"    public:",
			"    int n, m;",
			"    vector<vector<T>> matrix;",
			"    Matrix(int n, int m){",
			"        this->n = n;",
			"        this->m = m;",
			"        matrix = vector<vector<T>>(n, vector<T>(m));",
			"    }",
			"",
			"    Matrix<T> operator+(Matrix<T> &other){",
			"        assert(n == other.n && m == other.m);",
			"        Matrix<T> ans(n, m);",
			"        for (int i = 0; i < n; i++){",
			"            for (int j = 0; j < m; j++) ",
			"                ans.matrix[i][j] = matrix[i][j] + other.matrix[i][j];",
			"        }",
			"        return ans;",
			"    }",
			"",
			"    Matrix<T> operator-(Matrix<T> &other){",
			"        assert(n == other.n && m == other.m);",
			"        Matrix<T> ans(n, m);",
			"        for (int i = 0; i < n; i++){",
			"            for (int j = 0; j < m; j++) ",
			"                ans.matrix[i][j] = matrix[i][j] - other.matrix[i][j];",
			"        }",
			"        return ans;",
			"    }",
			"",
			"    Matrix<T> operator*(Matrix<T> &other){",
			"        assert(m == other.n);",
			"        Matrix<T> ans(n, other.m);",
			"        for (int i = 0; i < n; i++){",
			"            for (int j = 0; j < other.m; j++){",
			"                for (int k = 0; k < m; k++)",
			"                    ans.matrix[i][j] += matrix[i][k] + other.matrix[k][j];",
			"            }",
			"        }",
			"        return ans;",
			"    }",
			"",
			"    void operator+=(Matrix<T> other){",
			"        assert(n == other.n && m == other.m);",
			"        for (int i = 0; i < n; i++){",
			"            for (int j = 0; j < m; j++) ",
			"                matrix[i][j] += other.matrix[i][j];",
			"        }",
			"    }",
			"",
			"    void operator-=(Matrix<T> other){",
			"        assert(n == other.n && m == other.m);",
			"        for (int i = 0; i < n; i++){",
			"            for (int j = 0; j < m; j++) ",
			"                matrix[i][j] -= other.matrix[i][j];",
			"        }",
			"    }",
			"",
			"    void operator*=(Matrix<T> other){",
			"        assert(m == other.n);",
			"        Matrix<T> ans(n, other.m);",
			"        for (int i = 0; i < n; i++){",
			"            for (int j = 0; j < other.m; j++){",
			"                for (int k = 0; k < m; k++)",
			"                    ans.matrix[i][j] += matrix[i][k] * other.matrix[k][j];",
			"            }",
			"        }",
			"        matrix = ans.matrix;",
			"        m = other.m;",
			"    }",
			"",
			"    void operator=(Matrix<T> other){",
			"        n = other.n;",
			"        m = other.m;",
			"        matrix = other.matrix;",
			"    }",
			"};",
		],
	},

	"Binary exponent":{
		"prefix": "binary_exponent",
		"body": [
			"template<class A, class N>",
			"A binary_exponent(A a, N n){",
			"    assert(n > 0);",
			"    A ans = a;",
			"    n--;",
			"    while (n){",
			"        if (n & 1) ans *= a;",
			"        a *= a;",
			"        n >>= 1;",
			"    }",
			"    return ans;",
			"}",
		],
	},

	"Modular arithmetic":{
		"prefix": "modular_arithmetic",
		"body": [
			"class modll{",
			"	public:",
			"	long long val;",
			"	modll(long long val = 0){",
			"		this->val = val;",
			"	}",
			"",
			"	modll operator + (modll other){",
			"		return (val + other.val) % mod;",
			"	}",
			"",
			"	modll operator - (modll other){",
			"		return (val + mod - other.val) % mod;",
			"	}",
			"",
			"	modll operator * (modll other){",
			"		return val * other.val % mod;",
			"	}",
			"",
			"	modll operator / (modll other){",
			"		return val * other.inverse().val % mod;",
			"	}",
			"",
			"	modll power(long long n){",
			"		long long ans = 1, a = val;",
			"		while (n){",
			"			if (n & 1) ans = ans * a % mod;",
			"			a = a * a % mod;",
			"			n >>= 1;",
			"		}",
			"		return modll(ans);",
			"	}",
			"",
			"	modll inverse(){",
			"		return power(mod - 2);",
			"	}",
			"};",
			"",
			"istream &operator >> (istream &in, modll &a){",
			"	in >> a.val;",
			"	a.val = (a.val % mod + mod) % mod;",
			"	return in;",
			"}",
			"",
			"ostream &operator << (ostream &out, modll a){",
			"	out << a.val;",
			"	return out;",
			"}",
		],
	},

	"Segment Tree":{
		"prefix": "SegmentTree",
		"body":[
			"struct SegOp{",
			"    ll operator()(ll x, ll y){",
			"        return  x + y;",
			"    }",
			"};",
			"",
			"template<class T, class Op = SegOp>",
			"class SegmentTree{",
			"    public:",
			"    struct Node{",
			"        T val, updateVal;",
			"        bool pendingUpdate;",
			"        int l, r;",
			"        Node *left, *right;",
			"        Node(T val, int l, int r, Node *left, Node *right){",
			"            this->val = val;",
			"            this->l = l;",
			"            this->r = r;",
			"            this->left = left;",
			"            this->right = right;",
			"            this->pendingUpdate = false;",
			"        }",
			"    };",
			"",
			"    Node *root;",
			"    SegOp op;",
			"",
			"    Node *build(vector<T> &a, int l, int r){",
			"        if (l == r) return new Node(a[l], l, r, NULL, NULL);",
			"        int m = (l + r) >> 1;",
			"        Node *left = build(a, l, m);",
			"        Node *right = build(a, m + 1, r);",
			"        return new Node(op(left->val, right->val), l, r, left, right);",
			"    }",
			"",
			"    void build(vector<T> a){",
			"        root = build(a, 0, a.size() - 1);",
			"    }",
			"",
			"    T query(int l, int r, Node *node){",
			"        if (node->pendingUpdate) propogatePendingUpdate(node);",
			"        if (l == node->l && r == node->r) return node->val;",
			"        if (r <= node->left->r) return query(l, r, node->left);",
			"        if (l >= node->right->l) return query(l, r, node->right);",
			"        return op(query(l, node->left->r, node->left), query(node->right->l, r, node->right));",
			"    }",
			"",
			"    T query(int l, int r){",
			"        return query(l, r, root);",
			"    }",
			"",
			"    void propogatePendingUpdate(Node *node){",
			"        node->val += node->updateVal * (node->r - node->l + 1);",
			"        node->pendingUpdate = false;",
			"        if (node->left){",
			"            if (node->left->pendingUpdate) {",
			"                node->left->updateVal += node->updateVal;",
			"            }",
			"            else {",
			"                node->left->updateVal = node->updateVal;",
			"                node->left->pendingUpdate = true;",
			"            }",
			"            if (node->right->pendingUpdate) {",
			"                node->right->updateVal += node->updateVal;",
			"            }",
			"            else{",
			"                node->right->updateVal = node->updateVal;",
			"                node->right->pendingUpdate = true;",
			"            }",
			"        }",
			"    }",
			"",
			"    void update(int l, int r, T val, Node *node){",
			"        if (node->pendingUpdate) propogatePendingUpdate(node);",
			"        if (l == node->l && r == node->r){",
			"            node->pendingUpdate = true;",
			"            node->updateVal = val;",
			"            return;",
			"        }",
			"        if (r <= node->left->r) update(l, r, val, node->left);",
			"        else if (l >= node->right->l) update(l, r, val, node->right);",
			"        else {",
			"            update(l, node->left->r, val, node->left);",
			"            update(node->right->l, r, val, node->right);",
			"        }",
			"        if (node->left->pendingUpdate) propogatePendingUpdate(node->left);",
			"        if (node->right->pendingUpdate) propogatePendingUpdate(node->right);",
			"        node->val = op(node->left->val, node->right->val);",
			"    }",
			"",
			"    void update(int l, int r, T val){",
			"        update(l, r, val, root);",
			"    }",
			"};",
		],
	},

	"Extended Euclidean Algorithm":{
		"prefix": "extended_gcd",
		"body": [
			"template<class T>",
			"T extended_gcd(T a, T b, T &x, T &y){",
			"    x = 1, y = 0;",
			"    int x1 = 0, y1 = 1;",
			"    T temp, q;",
			"    while (b){",
			"        q = a / b;",
			"        temp = x;",
			"        x = x1;",
			"        x1 = temp - q * x1;",
			"        temp = y;",
			"        y = y1;",
			"        y1 = temp - q * y1;",
			"        temp = a;",
			"        a = b;",
			"        b = temp - q * b;",
			"    }",
			"    return a;",
			"}",
		],
	},

	"Fibonacci numbers":{
		"prefix": "fibonacci_number",
		"body": [
			"template<class A, class B>",
			"void fibonacci(A n, pair<B, B> &f){",
			"    if (n == 0) return;",
			"    fibonacci(n >> 1, f);",
			"    B c = f.first * (f.second * 2ll - f.first);",
			"    B d = f.first * f.first + f.second * f.second;",
			"    if (n & 1){",
			"        f.first = d;",
			"        f.second = c + d;",
			"    }",
			"    else{",
			"        f.first = c;",
			"        f.second = d;",
			"    }",
			"}",
		],
	},

	"Binary Exponent": {
		"prefix" : "power",
		"body" : [
			"template<class __num>",
			"__num power(__num a, __num n, __num mod){",
			"    __num ans = 1;",
			"    while (n){",
			"        if (n & 1) ans = (ans * a) % mod;",
			"        a = (a * a) % mod;",
			"        n >>= 1;",
			"    }",
			"    return ans;",
			"}",
		],
	},

	"Basic binary search tree":{
		"prefix": "BinarySearchTree",
		"body" : [
			"template<class T, class Cmp = less<T>>",
			"class BST{",
			"    public:",
			"    struct Node{",
			"        T val;",
			"        int height, size;",
			"        Node *left, *right, *parent;",
			"        Node(T val, int height, int size, Node *left, Node *right, Node *parent){",
			"            this->val = val;",
			"            this->height = height;",
			"            this->size = size;",
			"            this->left = left;",
			"            this->right = right;",
			"            this->parent = parent;",
			"        }",
			"        Node(){",
			"            this->height = 0;",
			"            this->size = 0;",
			"        }",
			"    };",
			"",
			"    Cmp cmp;",
			"    Node *null = new Node();",
			"    Node *root = null;",
			"",
			"    void update(Node *node){",
			"        node->height = max(node->left->height, node->right->height) + 1;",
			"        node->size = node->left->size + node->right->size + 1;",
			"    }",
			"",
			"    void rightRotate(Node *x){",
			"        Node *y = x->left;",
			"        Node *p = x->parent;",
			"        if (y->right != null) y->right->parent = x;",
			"        x->left = y->right;",
			"        x->parent = y;",
			"        y->right = x;",
			"        y->parent = p;",
			"        if (p == null) root = y;",
			"        else if (cmp(y->val, p->val)) p->left = y;",
			"        else p->right = y;",
			"        update(x);",
			"        update(y);",
			"    }",
			"",
			"    void leftRotate(Node *x){",
			"        Node *y = x->right;",
			"        Node *p = x->parent;",
			"        if (y->left != null) y->left->parent = x;",
			"        x->right = y->left;",
			"        x->parent = y;",
			"        y->left = x;",
			"        y->parent = p;",
			"        if (p == null) root = y;",
			"        else if (cmp(y->val, p->val)) p->left = y;",
			"        else p->right = y;",
			"        update(x);",
			"        update(y);",
			"    }",
			"",
			"    void insert(T val){",
			"        Node *parent = null, *curr = root;",
			"        while (curr != null){",
			"            parent = curr;",
			"            if (val == curr->val) return;",
			"            if (cmp(val, curr->val)) curr = curr->left;",
			"            else curr = curr->right;",
			"        }",
			"        Node *node = new Node(val, 1, 1, null, null, parent);",
			"        if (parent == null) root = node;",
			"        else if (cmp(val, parent->val)) parent->left = node;",
			"        else parent->right = node;",
			"        update(node);",
			"        subtreeFixup(node->parent);",
			"    }",
			"",
			"    void subtreeFixup(Node *node){",
			"        while (node != null){",
			"            update(node);",
			"            if (node->left->height == node->right->height + 2){",
			"                if (node->left->left->height + 2 == node->left->height) leftRotate(node->left);",
			"                rightRotate(node);",
			"            }",
			"            else if (node->right->height == node->left->height + 2){",
			"                if (node->right->right->height + 2 == node->right->height) rightRotate(node->right);",
			"                leftRotate(node);",
			"            }",
			"            node = node->parent;",
			"        }",
			"    }",
			"",
			"    void erase(T val){",
			"        Node *node = find(val);",
			"        if (node == null) return;",
			"        erase(node);",
			"    }",
			"",
			"    void erase(Node *node){",
			"        if (node->right == null){",
			"            if (node->left != null) node->left->parent = node->parent;",
			"            if (node->parent == null) root = node->left;",
			"            else if (node->parent->left == node) node->parent->left = node->left;",
			"            else node->parent->right = node->left;",
			"            subtreeFixup(node->parent);",
			"            return;",
			"        }",
			"        if (node->left == null){",
			"            node->right->parent = node->parent;",
			"            if (node->parent == null) root = node->right;",
			"            else if (node->parent->left == node) node->parent->left = node->right;",
			"            else node->parent->right = node->right;",
			"            subtreeFixup(node->parent);",
			"            return;",
			"        }",
			"        Node *toDelete = successor(node);",
			"        node->val = toDelete->val;",
			"        erase(toDelete);",
			"    }",
			"",
			"    Node *find(T val){",
			"        Node *node = root;",
			"        while (node != null){",
			"            if (val == node->val) return node;",
			"            if (cmp(val, node->val)) node = node->left;",
			"            else node = node->right;",
			"        }",
			"        return node;",
			"    }",
			"",
			"    Node *find_by_order(int i){",
			"        Node *node = root;",
			"        while (node != null){",
			"            if (node->left->size == i) return node;",
			"            if (node->left->size < i){",
			"                i -= node->left->size + 1;",
			"                node = node->right;",
			"            }",
			"            else node = node->left;",
			"        }",
			"        return node;",
			"    }",
			"",
			"    int order_of_key(T val){",
			"        int res = 0;",
			"        Node *node = root;",
			"        while (node != null){",
			"            if (val == node->val || cmp(val, node->val)) node = node->left;",
			"            else{",
			"                res += node->left->size + 1;",
			"                node = node->right;",
			"            }",
			"        }",
			"        return res;",
			"    }",
			"",
			"    Node *lower_bound(T val){",
			"        Node *res = null, *node = root;",
			"        while (node != null){",
			"            if (val == node->val || cmp(val, node->val)) {",
			"                res = node;",
			"                node = node->left;",
			"            }",
			"            else node = node->right;",
			"        }",
			"        return res;",
			"    }",
			"",
			"    Node *upper_bound(T val){",
			"        Node *res = null, *node = root;",
			"        while (node != null){",
			"            if (cmp(val, node->val)){",
			"                res = node;",
			"                node = node->left;",
			"            }",
			"            else node = node->right;",
			"        }",
			"        return res;",
			"    }",
			"",
			"    Node* successor(Node *node){",
			"        if (node->right != null){",
			"            node = node->right;",
			"            while (node->left != null) node = node->left;",
			"            return node;",
			"        }",
			"        while (node->parent->right == node) node = node->parent;",
			"        return node->parent;",
			"    }",
			"",
			"    Node *predecessor(Node *node){",
			"        if (node->left != null){",
			"            node = node->left;",
			"            while (node->right != null) node = node->right;",
			"            return node->right;",
			"        }",
			"        while (node->parent->left == node) node = node->parent;",
			"        return node->parent;",
			"    }",
			"",
			"    void inorderTraverse(){",
			"        inorderTraverse(root);",
			"        cerr << \"\\n\";",
			"    }",
			"",
			"    void inorderTraverse(Node *node){",
			"        if (node == null) return;",
			"        inorderTraverse(node->left);",
			"        cerr << node->val << \" \";",
			"        inorderTraverse(node->right);",
			"    }",
			"",
			"    void preorderTraverse(){",
			"        preorderTraverse(root);",
			"        cerr << \"\\n\";",
			"    }",
			"",
			"    void preorderTraverse(Node *node){",
			"        if (node == null) return;",
			"        cerr << node->val << \" \";",
			"        preorderTraverse(node->left);",
			"        preorderTraverse(node->right);",
			"    }",
			"",
			"    void postorderTraverse(){",
			"        postorderTraverse(root);",
			"        cerr << \"\\n\";",
			"    }",
			"",
			"    void postorderTraverse(Node *node){",
			"        if (node == null) return;",
			"        postorderTraverse(node->left);",
			"        postorderTraverse(node->right);",
			"        cerr << node->val << \" \";",
			"    }",
			"",
			"    Node* begin(){",
			"        Node *node = root;",
			"        while (node->left != null) node = node->left;",
			"        return node;",
			"    }",
			"",
			"    Node* end(){",
			"        Node *node = root;",
			"        while (node->right != null) node = node->right;",
			"        return node;",
			"    }",
			"};",
		],
	},

	"Sparse Table":{
		"prefix": "SparseTable",
		"body": [
			"template<class T>",
			"struct SparseOp{",
			"    T operator()(T u, T v){",
			"        return min(u, v);",
			"    }",
			"};",
			"",
			"template<class T, class Op = SparseOp<T>>",
			"class SparseTable{",
			"    public:",
			"    vector<vector<T>> table;",
			"    Op op;",
			"",
			"    SparseTable(){}",
			"",
			"    void build(vector<T> a){",
			"        int n = a.size();",
			"        int height = 32 - __builtin_clz(n);",
			"        table = vector<vector<T>>(n, vector<T>(height));",
			"        for (int i = 0; i < n; i++) table[i][0] = a[i];",
			"        for (int j = 1; j < height; j++){",
			"            for (int i = 0; i + (1 << (j - 1)) < n; i++){",
			"                table[i][j] = op(table[i][j - 1], table[i + (1 << (j - 1))][j - 1]);",
			"            }",
			"        }",
			"    }",
			"",
			"    T query(int l, int r){",
			"        int len = r - l + 1;",
			"        int depth = 31 - __builtin_clz(len);",
			"        return op(table[l][depth], table[r - (1 << depth) + 1][depth]);",
			"    }",
			"};",
		],
	},

	"Prime Factors":{
		"prefix":"PrimeFactors",
		"body":[
			"vector<ll> primeFactor;",
			"vector<ll> factorCount;",
			"",
			"void getFactors(ll n){",
			"    primeFactor = vector<ll>(n + 1);",
			"    for (ll i = 1; i <= n; i++) primeFactor[i] = i;",
			"    for (ll i = 2; i * i <= n; i++){",
			"        for (ll j = i; j <= n; j += i){",
			"            if (i < primeFactor[j]) primeFactor[j] = i;",
			"        }",
			"    }",
			"}",
			"",
			"void countFactors(ll n){",
			"    factorCount = vector<ll>(n + 1);",
			"    factorCount[1] = 1;",
			"    for (ll i = 2; i <= n; i++){",
			"        ll cnt = 0;",
			"        ll j;",
			"        for (j = i; j % primeFactor[i] == 0; j /= primeFactor[i]) cnt++;",
			"        factorCount[i] = (cnt + 1) * factorCount[j];",
			"    }",
			"}",
		],
	},

	"Mobius function":{
		"prefix":"MobiusFunction",
		"body": [
			"void init(){",
			"    for (int64_t i = 1; i <= MX; i++) primeFactor[i] = i;",
			"    for (int64_t i = 2; i * i <= MX; i++){",
			"        if (primeFactor[i] != i) continue;",
			"        for (int64_t j = i * i; j <= MX; j += i){",
			"            if (i < primeFactor[j]) primeFactor[j] = i;",
			"        }",
			"    }",
			"    mobius[1] = 1;",
			"    for (int64_t i = 2; i <= MX; i++){",
			"        if (primeFactor[i] == i) mobius[i] = -1;",
			"        else if (primeFactor[i] == primeFactor[i / primeFactor[i]]) mobius[i] = 0;",
			"        else mobius[i] = mobius[primeFactor[i]] * mobius[i / primeFactor[i]];",
			"    }",
			"}",
		],
	},

	"Permutation exponent":{
		"prefix": "permutation_exponent",
		"body": [
			"template<class T, class N>",
			"void permutation_exponent(vector<T> &a, N n){",
			"    assert(n > 0);",
			"    vector<T> ans = a;",
			"    vector<T> temp(a.size());",
			"    n--;",
			"    while (n){",
			"        if (n & 1){",
			"            for (int i = 0; i < a.size(); i++) temp[i] = ans[a[i]];",
			"            for (int i = 0; i < a.size(); i++) ans[i] = temp[i];",
			"        }",
			"        n >>= 1;",
			"        for (int i = 0; i < a.size(); i++) temp[i] = a[a[i]];",
			"        for (int i = 0; i < a.size(); i++) a[i] = temp[i];",
			"    }",
			"    for (int i = 0; i < a.size(); i++) a[i] = ans[i];",
			"}",
		],
	},

	"Millar Rabin Prime Detection":{
		"prefix": "millarRabin",
		"body": [
			"ll power(ll a, ll n, ll mod){",
			"    ll ans = 1;",
			"    while (n){",
			"        if (n & 1) ans = (__uint128_t) ans * a % mod;",
			"        a = (__uint128_t)a * a % mod;",
			"        n >>= 1;",
			"    }",
			"    return ans;",
			"}",
			"",
			"bool checkComposite(ll n, ll a, ll d, ll s){",
			"    ll x = power(a, d, n);",
			"    if (x == 1 || x == n - 1) return false;",
			"    for (ll r = 1; r < s; r++){",
			"        x = (__uint128_t)x * x % n;",
			"        if (x == n - 1) return false;",
			"    }",
			"    return true;",
			"}",
			"",
			"bool millarRabin(ll n){",
			"    if (n < 2) return false;",
			"    ll r = 0;",
			"    ll d = n - 1;",
			"    while ((d & 1) == 0){",
			"        d >>= 1;",
			"        r++;",
			"    }",
			"    for (ll a: {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37}){",
			"        if (a == n) return true;",
			"        if (checkComposite(n, a, d, r)) return false;",
			"    }",
			"    return true;",
			"}",
		],
	},

	"Operator Stack":{
		"prefix": "StackOperator",
		"body": [
			"template<class T>",
			"struct StackOp{",
			"    T operator()(T a, T b){",
			"        return max(a, b);",
			"    }",
			"};",
			"",
			"template<class T, class Op = StackOp<T>>",
			"class OpStack{",
			"    stack<T, T> stk;",
			"    Op op;",
			"    OpStack(){}",
			"",
			"    void push(T x){",
			"        if (stk.empty()) stk.push({T, T});",
			"        else stk.push({T, op(T, stk.top().second)});",
			"    }",
			"",
			"    void pop(){",
			"        stk.pop();",
			"    }",
			"",
			"    T top(){",
			"        return stk.top().first;",
			"    }",
			"",
			"    T get(){",
			"        return stk.top().second;",
			"    }",
			"};",
		],
	},

	"Operator Queue":{
		"prefix": "QueueOperator",
		"body":[
			"template<class T>",
			"struct QueueOp{",
			"    T operator()(T a, T b){",
			"        return max(a, b);",
			"    }",
			"};",
			"",
			"template<class T, class Op = QueueOp<T>>",
			"class OpQueue{",
			"    public:",
			"    stack<pair<T, T>> inStack, outStack;",
			"    Op op;",
			"    OpQueue(){}",
			"",
			"    void push(T x){",
			"        if (inStack.empty()) inStack.push({x, x});",
			"        else inStack.push({x, op(x, inStack.top().second)});",
			"    }",
			"",
			"    void transfer(){",
			"        while (!inStack.empty()){",
			"            T x = inStack.top().first;",
			"            inStack.pop();",
			"            T mn = outStack.empty() ? x : op(x, outStack.top().second);",
			"            outStack.push({x, mn});",
			"        }",
			"    }",
			"",
			"    void pop(){",
			"        if (outStack.empty()) transfer();",
			"        outStack.pop();",
			"    }",
			"",
			"    T front(){",
			"        if (outStack.empty()) transfer();",
			"        return outStack.top().first;",
			"    }",
			"",
			"    T get(){",
			"        if (inStack.empty()) return outStack.top().second;",
			"        if (outStack.empty()) return inStack.top().second;",
			"        return op(inStack.top().second, outStack.top().second);",
			"    }",
			"};",
		],
	},

	"Combinatorics":{
		"prefix": "factorial",
		"body": [
			"vector<ll> factorial, invFactorial;",
			"",
			"ll power(ll a, ll n){",
			"    ll ans = 1;",
			"    while (n){",
			"        if (n & 1) ans = (ans * a) % mod;",
			"        a = (a * a) % mod;",
			"        n >>= 1;",
			"    }",
			"    return ans;",
			"}",
			"",
			"ll inverse(ll a){",
			"    return power(a, mod - 2);",
			"}",
			"",
			"void getFactorials(ll n){",
			"    factorial.resize(n + 1);",
			"    invFactorial.resize(n + 1);",
			"    factorial[0] = 1;",
			"    for (ll i = 1; i <= n; i++){",
			"        factorial[i] = (factorial[i - 1] * i) % mod;",
			"    }",
			"    invFactorial[n] = inverse(factorial[n]);",
			"    for (ll i = n - 1; i >= 0; i--){",
			"        invFactorial[i] = (invFactorial[i + 1] * (i + 1)) % mod;",
			"    }",
			"}",
			"",
			"ll nCr(ll n, ll r){",
			"    if (n < r) return 0;",
			"    ll ans = (invFactorial[r] * invFactorial[n - r]) % mod;",
			"    ans = (ans * factorial[n]) % mod;",
			"    return ans;",
			"}",
		],
	},

	"Trie":{
		"prefix": "Trie",
		"body":[
			"class Trie{",
			"    public:",
			"    struct Node{",
			"        bool isComplete;",
			"        vector<Node*> child;",
			"        Node(bool complete){",
			"            this->isComplete = complete;",
			"            child = vector<Node*>(128);",
			"        }",
			"    };",
			"",
			"    Node *root;",
			"",
			"    Trie(){",
			"        root = new Node(false);",
			"    }",
			"",
			"    void insert(string s){",
			"        Node *curr = root;",
			"        for (char c: s){",
			"            if (!curr->child[c]) curr->child[c] = new Node(false);",
			"            curr = curr->child[c];",
			"        }",
			"        curr->isComplete = true;",
			"    }",
			"",
			"    bool available(string s){",
			"        Node *curr = root;",
			"        for (char c: s){",
			"            if (!curr->child[c]) return false;",
			"            curr = curr->child[c];",
			"        }",
			"        return curr->isComplete;",
			"    }",
			"};",
		],
	},

	"FastSegmentTree":{
		"prefix": "FastSegmentTree",
		"body": [
			"template<class T>",
			"class SegmentTree{",
			"    public:",
			"    struct Op{",
			"        T operator()(T a, T b){",
			"            return min(a, b);",
			"        }",
			"    };",
			"",
			"    Op op;",
			"    int p;",
			"    vector<T> tree;",
			"",
			"    SegmentTree(){}",
			"    void build(vector<T> a){",
			"        int n = a.size();",
			"        p = 1;",
			"        while (p < n) p <<= 1;",
			"        tree.resize(2 * p);",
			"        for (int i = 0; i < n; i++) tree[i + p] = a[i];",
			"        for (int i = p - 1; i > 0; i--) tree[i] = op(tree[i << 1], tree[(i << 1) + 1]);",
			"    }",
			"",
			"    T query(int l, int r){",
			"        return query(l, r, 0, p - 1, 1);",
			"    }",
			"",
			"    T query(int l, int r, int tl, int tr, int i){",
			"        if (l == tl && r == tr) return tree[i];",
			"        int m = (tl + tr) >> 1;",
			"        i <<= 1;",
			"        if (r <= m) return query(l, r, tl, m, i);",
			"        if (l > m) return query(l, r, m + 1, tr, i + 1);",
			"        return op(query(l, m, tl, m, i), query(m + 1, r, m + 1, tr, i + 1));",
			"    }",
			"",
			"    void update(int i, T x){",
			"        i += p;",
			"        tree[i] = x;",
			"        while (i > 1){",
			"            i >>= 1;",
			"            tree[i] = op(tree[i << 1], tree[(i << 1) + 1]);",
			"        }",
			"    }",
			"};",
		],
	},

	"DSU":{
		"prefix": "DSU",
		"body":[
			"class DSU{",
			"    public:",
			"    vector<ll> parent, size;",
			"",
			"    DSU(ll n = 0){",
			"        parent = vector<ll>(n + 1);",
			"        size = vector<ll>(n + 1);",
			"        for (ll i = 1; i <= n; i++) size[i] = 1;",
			"        for (ll i = 1; i <= n; i++) parent[i] = i;",
			"    }",
			"",
			"    ll find_set(ll x){",
			"        if (parent[x] == x) return x;",
			"        ll p = find_set(parent[x]);",
			"        parent[x] = p;",
			"        return p;",
			"    }",
			"",
			"    void union_set(ll x, ll y){",
			"        ll px = find_set(x);",
			"        ll py = find_set(y);",
			"        if (px == py) return;",
			"        size[px] += size[py];",
			"        parent[py] = px;",
			"    }",
			"",
			"    ll get_size(ll x){",
			"        return size[find_set(x)];",
			"    }",
			"};",
		],
	},

	"Flow Graph":{
		"prefix": "flowGraph",
		"body":[
			"class FlowGraph{",
			"    public:",
			"    int n, so, si;",
			"    vector<vector<int>> adj;",
			"    FlowGraph(){}",
			"    FlowGraph(int n, int so, int si){",
			"        this->n = n;",
			"        this->so = so;",
			"        this->si = si;",
			"        adj = vector<vector<int>>(n + 1, vector<int>(n + 1));",
			"    }",
			"    void addEdge(int u, int v, int w){",
			"        adj[u][v] += w;",
			"    }",
			"",
			"    bool getPath(int x, int dest, vector<vector<int>> &adj, vector<bool> &visited, vector<int> &path){",
			"        path.push_back(x);",
			"        visited[x] = true;",
			"        if (x == dest) return true;",
			"        for (int y = 1; y <= n; y++){",
			"            if (adj[x][y] > 0 && !visited[y]){",
			"                if (getPath(y, dest, adj, visited, path)) return true;",
			"            }",
			"        }",
			"        path.pop_back();",
			"        return false;",
			"    }",
			"    int getMaxFlow(){",
			"        vector<vector<int>> adj = this->adj;",
			"        vector<bool> visited(n + 1);",
			"        vector<int> path;",
			"        bool found = getPath(so, si, adj, visited, path);",
			"        int ans = 0;",
			"        while (found){",
			"            int mn = INT32_MAX;",
			"            for (int i = 1; i < path.size(); i++) {",
			"                int temp = adj[path[i - 1]][path[i]];",
			"                mn = min(mn, adj[path[i - 1]][path[i]]);",
			"            }",
			"            ans += mn;",
			"            for (int i = 1; i < path.size(); i++){",
			"                adj[path[i - 1]][path[i]] -= mn;",
			"                adj[path[i]][path[i - 1]] += mn;",
			"            }",
			"            visited = vector<bool>(n + 1);",
			"            path = vector<int>();",
			"            found = getPath(so, si, adj, visited, path);",
			"        }",
			"        return ans;",
			"    }",
			"};",
		],
	},

	"Floyd Warshall":{
		"prefix": "floydwarshall",
		"body":[
			"// Parent is matrix received from floydWarshall",
			"void getPath(ll i, ll j, vector<vector<ll>> &parent, vector<ll> &path){",
			"    if (parent[i][j] == 0){",
			"        path.push_back(i);",
			"        if (i != j) path.push_back(j);",
			"        return;",
			"    }",
			"    getPath(i, parent[i][j], parent, path);",
			"    path.pop_back();",
			"    getPath(parent[i][j], j, parent, path);",
			"}",
			" ",
			"// Weight is infinity if there is no edge from i -> j and weight[i][i] = 0",
			"void floydWarshall(vector<vector<ll>> weight, vector<vector<ll>> &dist, vector<vector<ll>> &parent){",
			"    const ll inf = 1e18, n = weight.size() - 1;",
			"    dist = weight;",
			"    for (ll k = 1; k <= n; k++){",
			"        for (ll i = 1; i <= n; i++){",
			"            for (ll j = 1; j <= n; j++){",
			"                if (dist[i][k] < inf && dist[k][j] < inf && dist[i][k] + dist[k][j] < dist[i][j]){",
			"                    dist[i][j] = dist[i][k] + dist[k][j];",
			"                    parent[i][j] = k;",
			"                }",
			"            }",
			"        }",
			"    }",
			"}",
		],
	},

	"Least Common Ancestor":{
		"prefix": "leastCommonAncestor",
		"body":[
			"vector<pair<ll, ll>> eulerTour;",
			"vector<ll> firstOccur;",
			"SparseTable<pair<ll, ll>> table;",
			"",
			"void getEulerTour(ll x, ll p = 0, ll d = 0){",
			"    firstOccur[x] = eulerTour.size();",
			"    eulerTour.emplace_back(d, x);",
			"    for (ll y: adj[x]){",
			"        if (y == p) continue;",
			"        getEulerTour(y, x, d + 1);",
			"        eulerTour.emplace_back(d, x);",
			"    }",
			"}",
			"",
			"ll lca(ll x, ll y){",
			"    ll l = firstOccur(x);",
			"    ll r = firstOccur(y);",
			"    if (r < l) swap(l, r);",
			"    return table.query(l, r).second;",
			"}",
		],
	},

	"Merge Sort":{
		"prefix": "MergeSort",
		"body":[
			"template<class T>",
			"void mergeSort(vector<T> &a){",
			"    int len = 1, n = a.size();",
			"    while (len <= n) len <<= 1;",
			"    T mx = a[0];",
			"    for (T &x: a) mx = max(x, mx);",
			"    a.resize(len, mx);",
			"    vector<T> temp(len);",
			"    for (int l = 1; l < len; l <<= 1){",
			"        for (int i = 0; i + (l << 1) - 1 < len; i += (l << 1)){",
			"            int u = 0, v = 0, s = 0;",
			"            while (u < l && v < l){",
			"                if (a[i + u] < a[i + l + v]) temp[i + s++] = a[i + u++];",
			"                else temp[i + s++] = a[i + l + v++];",
			"            }",
			"            while (u < l) temp[i + s++] = a[i + u++];",
			"            while (v < l) temp[i + s++] = a[i + l + v++];",
			"        }",
			"        swap(a, temp);",
			"    }",
			"    a.resize(n);",
			"}",
		],
	},

	"Fast Fourier Transform":{
		"prefix": "fastfouriertransform",
		"body":[
			"using cd = complex<long double>;",
			"const long double PI = acos(-1);",
			"",
			"int reverse(int num, int lg_n) {",
			"	int res = 0;",
			"	for (int i = 0; i < lg_n; i++) {",
			"		if (num & (1 << i))",
			"			res |= 1 << (lg_n - 1 - i);",
			"	}",
			"	return res;",
			"}",
			"",
			"void fft(vector<cd> & a, bool invert) {",
			"	int n = a.size();",
			"	int lg_n = 0;",
			"	while ((1 << lg_n) < n) lg_n++;",
			"",
			"	for (int i = 0; i < n; i++) {",
			"		if (i < reverse(i, lg_n)) swap(a[i], a[reverse(i, lg_n)]);",
			"	}",
			"",
			"	for (int len = 2; len <= n; len <<= 1) {",
			"		long double ang = 2 * PI / len * (invert ? -1 : 1);",
			"		// cd wlen(cos(ang), sin(ang));",
			"		for (int i = 0; i < n; i += len) {",
			"			// cd w(1);",
			"			for (int j = 0; j < len / 2; j++) {",
			"				cd w(cos(j * ang), sin(j * ang));",
			"				cd u = a[i + j], v = a[i + j + len / 2] * w;",
			"				a[i + j] = u + v;",
			"				a[i + j + len / 2] = u - v;",
			"				// w *= wlen;",
			"			}",
			"		}",
			"	}",
			"",
			"	if (invert) {",
			"		for (cd &x : a) x /= n;",
			"	}",
			"}",
			"",
			"template<class T>",
			"vector<T> multiply(vector<T> a, vector<T> b){",
			"	int n = 1;",
			"	while (n < a.size() || n < b.size()) n <<= 1;",
			"	vector<cd> u(2 * n), v(2 * n);",
			"	for (int i = 0; i < a.size(); i++) u[i] = a[i];",
			"	for (int i = 0; i < b.size(); i++) v[i] = b[i];",
			"	fft(u, false);",
			"	fft(v, false);",
			"	for (int i = 0; i < 2 * n; i++) u[i] *= v[i];",
			"	fft(u, true);",
			"	vector<T> res(a.size() + b.size() - 1);",
			"	for (int i = 0; i < res.size(); i++) res[i] = roundl(u[i].real());",
			"	return res;",
			"}",
			"",
			"vector<ll> multiply(vector<ll> a, vector<ll> b, ll mod){",
			"	ll S = sqrtl(mod);",
			"	ll S2 = S * S % mod;",
			"	vector<ll> a0 = a, a1 = a, b0 = b, b1 = b;",
			"	for (ll i = 0; i < a0.size(); i++){",
			"		a1[i] /= S;",
			"		a0[i] %= S;",
			"		b1[i] /= S;",
			"		b0[i] %= S;",
			"		a[i] = (a0[i] + a1[i]) % mod;",
			"		b[i] = (b0[i] + b1[i]) % mod;",
			"	}",
			"	vector<ll> u0 = multiply(a0, b0);",
			"	vector<ll> u1 = multiply(a, b);",
			"	vector<ll> u2 = multiply(a1, b1);",
			"	for (ll i = 0; i < u0.size(); i++){",
			"		u0[i] %= mod;",
			"		u1[i] %= mod;",
			"		u2[i] %= mod;",
			"		u0[i] = (u0[i] + (u1[i] + mod - u0[i] + mod - u2[i]) % mod * S % mod + u2[i] * S2 % mod) % mod;",
			"	}",
			"	return u0;",
			"}",
		],
	},

	"square root":{
		"prefix": "sqrt",
		"body": [
			"ll sqrt(ll x){",
			"    if (x == 0 || x == 1) return x;",
			"    ll y = sqrt(x >> 2);",
			"    y <<= 1;",
			"    if ((y + 1) * (y + 1) > x) return y;",
			"    return y + 1;",
			"}",
		],
	},

	"nC2": {
		"prefix": "nC2",
		"body":[
			"inline ll nC2(ll x){",
			"    return x * (x - 1) / 2;",
			"}",
		],
	},

	"SAT":{
		"prefix": "SAT",
		"body":[
			"class SAT{",
			"    int n;",
			"    vector<vector<int>> adj, adj_t;",
			"    vector<bool> used;",
			"    vector<int> order, comp;",
			"    vector<bool> assignment;",
			"    public:",
			"    SAT(int n = 0): n(n){",
			"        adj = vector<vector<int>>(2 * n + 2);",
			"        adj_t = vector<vector<int>>(2 * n + 2);",
			"    }",
			"",
			"    void dfs1(int x){",
			"        used[x] = true;",
			"        for (int y: adj[x]){",
			"            if (!used[y]) dfs1(y);",
			"        }",
			"        order.push_back(x);",
			"    }",
			"",
			"    void dfs2(int x, int c){",
			"        comp[x] = c;",
			"        for (int y: adj_t[x]){",
			"            if (comp[y] == -1) dfs2(y, c);",
			"        }",
			"    }",
			"",
			"",
			"    bool solve(){",
			"        order.clear();",
			"        used = vector<bool>(2 * n + 2);",
			"        removeDuplicates();",
			"        for (int i = 0; i < 2 * n + 2; i++){",
			"            if (!used[i]) dfs1(i);",
			"        }",
			"        comp = vector<int>(2 * n + 2, -1);",
			"        for (int i = 0, j = 0; i < 2 * n + 2; i++){",
			"            int v = order[2 * n - i + 1];",
			"            if (comp[v] == -1) dfs2(v, j++);",
			"        }",
			"",
			"        assignment = vector<bool>(n + 1);",
			"        for (int i = 0; i < n; i += 2){",
			"            if (comp[i] == comp[i + 1]) return false;",
			"            assignment[i >> 1] = comp[i] > comp[i + 1];",
			"        }",
			"        return true;",
			"    }",
			"",
			"    void add_disjunction(int a, int b, bool neg_a, bool neg_b){",
			"        a <<= 1;",
			"        a ^= neg_a;",
			"        b <<= 1;",
			"        b ^= neg_b;",
			"        int na = a ^ 1;",
			"        int nb = b ^ 1;",
			"        adj[na].push_back(b);",
			"        adj[nb].push_back(a);",
			"        adj_t[b].push_back(na);",
			"        adj_t[a].push_back(nb);",
			"    }",
			"",
			"    void removeDuplicates(){",
			"        for (auto &v: adj){",
			"            sort(v.begin(), v.end());",
			"            int j = 1;",
			"            for (int i = 1; i < v.size(); i++){",
			"                if (v[i] != v[i - 1]) v[j++] = v[i];",
			"            }",
			"            v.resize(j);",
			"        }",
			"    }",
			"};",
		],
	},
	"Persistent Segment Tree":{
		"prefix": "persistentSegmentTree",
		"body": [
			"template<class T>",
			"struct Op{",
			"    T operator()(T a, T b){",
			"        return a + b;",
			"    }",
			"};",
			"",
			"template<class T, class SegOp=Op<T>>",
			"class persistentSegmentTree{",
			"    public:",
			"    struct Node{",
			"        T val;",
			"        int l, r;",
			"        Node *left, *right;",
			"        Node(){}",
			"        Node(T val, int l, int r, Node *left = nullptr, Node *right = nullptr): val(val), l(l), r(r), left(left), right(right){}",
			"    };",
			"    SegOp op;",
			"    vector<Node*> root;",
			"",
			"    void build(vector<T> a){",
			"        root.push_back(build(a, 0, a.size() - 1));",
			"    }",
			"",
			"    Node* build(vector<T> &a, int l, int r){",
			"        if (l == r) return new Node(a[l], l, r);",
			"        int m = (l + r) >> 1;",
			"        Node *left = build(a, l, m);",
			"        Node *right = build(a, m + 1, r);",
			"        return new Node(op(left->val, right->val), l, r, left, right);",
			"    }",
			"",
			"    T query(int l, int r, int t){",
			"        return query(l, r, root[t]);",
			"    }",
			"",
			"    T query(int l, int r, Node *root){",
			"        if (root->l == l && root->r == r) return root->val;",
			"        if (r <= root->left->r) return query(l, r, root->left);",
			"        if (l >= root->right->l) return query(l, r, root->right);",
			"        return op(query(l, root->left->r, root->left), query(root->right->l, r, root->right));",
			"    }",
			"",
			"    void update(int i, T x){",
			"        root.push_back(update(i, x, root.back()));",
			"    }",
			"",
			"    Node *update(int i, T x, Node *root){",
			"        if (root->l == root->r) return new Node(x, i, i);",
			"        Node *left = root->left, *right = root->right;",
			"        if (i <= root->left->r) left = update(i, x, left);",
			"        else right = update(i, x, right);",
			"        return new Node (op(left->val, right->val), root->l, root->r, left, right);",
			"    }",
			"};",
		],
	},
	"Big Integer":{
		"prefix": "bigInteger",
		"body": [
			"template<int size>",
			"class BigInteger{",
			"	public:",
			"	bitset<size> val;",
			"",
			"	BigInteger(): val(0){}",
			"	BigInteger(bitset<size> val): val(val){}",
			"",
			"	void addString(string &a, string &b){",
			"		reverse(a.begin(), a.end());",
			"		reverse(b.begin(), b.end());",
			"		while (a.size() < b.size()) a += '0';",
			"		while (b.size() < a.size()) b += '0';",
			"		int carry = 0;",
			"		for (int i = 0; i < a.size(); i++){",
			"			int temp = a[i] - '0' + b[i] - '0' + carry;",
			"			carry = temp / 10;",
			"			a[i] = temp % 10 + '0';",
			"		}",
			"		if (carry) a += '1';",
			"		reverse(a.begin(), a.end());",
			"		reverse(b.begin(), b.end());",
			"	}",
			"",
			"	void doubleString(string &a){",
			"		reverse(a.begin(), a.end());",
			"		int carry = 0;",
			"		for (int i = 0; i < a.size(); i++){",
			"			int temp = (a[i] - '0') * 2 + carry;",
			"			carry = temp / 10;",
			"			a[i] = temp % 10 + '0';",
			"		}",
			"		if (carry) a += '1';",
			"		reverse(a.begin(), a.end());",
			"	}",
			"",
			"	string convToString(){",
			"		bool neg = val[size - 1];",
			"		if (neg) complement();",
			"		string res = \"0\", temp = \"1\";",
			"		for (int i = 0; i < size; i++){",
			"			if (val[i]) addString(res, temp);",
			"			doubleString(temp);",
			"		}",
			"		if (neg){",
			"			complement();",
			"			res = \"-\" + res;",
			"		}",
			"		return res;",
			"	}",
			"",
			"	void complement(){",
			"		val.flip();",
			"		for (int i = 0; i < size; i++){",
			"			if (val[i]) val[i] = 0;",
			"			else{",
			"				val[i] = 1;",
			"				break;",
			"			}",
			"		}",
			"	}",
			"",
			"	BigInteger operator+ (BigInteger other){",
			"		BigInteger res;",
			"		int carry = 0;",
			"		for (int i = 0; i < size; i++){",
			"			res.val[i] = (other.val[i] + val[i] + carry) & 1;",
			"			carry = (other.val[i] + val[i] + carry) >> 1;",
			"		}",
			"		return res;",
			"	}",
			"",
			"	void doubleVal(){",
			"		int carry = 0;",
			"		for (int i = 0; i < size; i++){",
			"			int temp = val[i] * 2 + carry;",
			"			val[i] = temp & 1;",
			"			carry = temp >> 1;",
			"		}",
			"	}",
			"",
			"	BigInteger operator-(BigInteger other){",
			"		other.complement();",
			"		return this->operator+(other);",
			"	}",
			"",
			"	BigInteger operator*(BigInteger other){",
			"		BigInteger res;",
			"		for (int i = 0; i < size; i++){",
			"			if (val[i]) res = res + other;",
			"			other.doubleVal();",
			"		}",
			"		return res;",
			"	}",
			"};",
		],
	},
	"Geometry":{
		"prefix": "geometry",
		"body": [
			"struct vec{",
			"    long long x, y;",
			"    vec(long long x = 0, long long y = 0): x(x), y(y){}",
			"    vec operator+ (vec other) const{",
			"        return vec(x + other.x, y + other.y);",
			"    }",
			"    vec operator- (vec other) const{",
			"        return vec(x - other.x, y - other.y);",
			"    }",
			"    void operator+= (vec other){",
			"        x += other.x;",
			"        y += other.y;",
			"    }",
			"    void operator-= (vec other){",
			"        x -= other.x;",
			"        y -= other.y;",
			"    }",
			"    long long dot(vec other){",
			"        return x * other.x + y * other.y;",
			"    }",
			"    long long cross(vec other){",
			"        return x * other.y - y * other.x;",
			"    }",
			"    long long triangle(vec a, vec b){",
			"        return (a.x - x) * (b.y - y) - (a.y - y) * (b.x - x);",
			"    }",
			"    long long modSq(){",
			"        return x * x + y * y;",
			"    }",
			"    long long distSq(vec other){",
			"        return (x - other.x) * (x - other.x) + (y - other.y) * (y - other.y);",
			"    }",
			"    long long mod(){",
			"        return sqrtl(modSq());",
			"    }",
			"    long long dist(vec other){",
			"        return sqrtl(distSq(other));",
			"    }",
			"    long double angle(vec other){",
			"        return acosl(dot(other) / mod() / other.mod());",
			"    }",
			"    bool operator < (vec other){",
			"        return x < other.x || x == other.x && y < other.y;",
			"    }",
			"};",
			"",
			"istream &operator>> (istream& in, vec &v){",
			"    in >> v.x >> v.y;",
			"    return in;",
			"}",
			"",
			"ostream &operator<< (ostream &out, vec v){",
			"    out << v.x << \" \" << v.y;",
			"    return out;",
			"}",
		],
	},
	"Interpolation":{
		"prefix":"interpolation",
		"body":[
			"ll interpolate(vector<ll> a, ll x){",
			"    ll d = a.size() - 1, ans = 0;",
			"    if (x <= d) return a[x];",
			"    for (ll i = 0; i <= d; i++){",
			"        ll temp = a[i] * inverse(x - i) % mod * invFactorial[i] % mod * invFactorial[d - i] % mod;",
			"        if ((d - i) & 1) ans = (ans + mod - temp) % mod;",
			"        else ans = (ans + temp) % mod;",
			"    }",
			"    for (ll i = x - d; i <= x; i++) ans = ans * i % mod;",
			"    return ans;",
			"}",
		],
	},
}
